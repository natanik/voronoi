package ru.animalware.geo.voronoi

import com.typesafe.scalalogging.Logger
import org.slf4j.LoggerFactory

import scala.annotation.tailrec
import scala.collection.SortedSet
import scala.collection.immutable.TreeSet

class Fortunes(val sites: Iterable[Point]) {

  require(sites.size > 2, "The sites count must be 3 or more")

  private val log = Logger(LoggerFactory.getLogger(this.getClass))
  private val extremities: Array[Point => Double] = Array(_.x, -_.x, _.y, -_.y)
  private val cornerIndexes: Array[(Int, Int)] = Array((0, 2), (0, 3), (1, 2), (1, 3))

  implicit def eventOrdering[T <: Event] = new Ordering[T] {

    override def compare(x: T, y: T): Int = x.compare(y)
  }

  private val events = SortedSet.empty[SiteEvent] ++ sites.map(SiteEvent)

  def create(): Iterable[Polygon] = {

    @tailrec
    def manageNextEvent(siteEvents: SortedSet[SiteEvent], beach: BeachLine, edges: Set[Edge] = Set.empty, iterations: Int = 1):
    (Set[Edge], Int, BeachLine) = {
      if (siteEvents.isEmpty && beach.circleEvents.isEmpty) (edges, iterations, beach)
      else {
        val ce = if (siteEvents.nonEmpty) beach.circleEvents.filter(e => e != null && e < siteEvents.head) else beach.circleEvents
        val ( newSiteEvents, (newBeach, newEdges)) = if (ce.isEmpty) (siteEvents.tail, beach.manageEvent(siteEvents.head, edges))
        else (siteEvents, beach.manageEvent(ce.head, edges))
        manageNextEvent(newSiteEvents, newBeach, newEdges, iterations + 1)
      }
    }

    val (edges, iterations, beach) = manageNextEvent(events.tail, BeachLine(events.head.point))
    log.info(f"$iterations iterations")

    val polygons = edges.foldLeft(Map[Point, Set[Point]]()) { (m: Map[Point, Set[Point]], e: Edge) =>
      m + (m.get(e.left) match {
        case set: Some[Set[Point]] => e.left -> (set.get ++ Set(e.start, e.end))
        case None => e.left -> Set(e.start, e.end)
      }) + (m.get(e.right) match {
        case set: Some[Set[Point]] => e.right -> (set.get ++ Set(e.start, e.end))
        case None => e.right -> Set(e.start, e.end)
      })
    }

    val vertices = polygons flatMap(_._2)
    val siteExtremes = extremities.map(sites minBy _).zipWithIndex
    val extremes = extremities map {(sites ++ vertices) minBy _}

    @tailrec
    def getRestOfEdges(segments: Vector[Segment], polygons: Map[Point, Set[Point]], crossings: Set[(Point, Point)] = Set.empty):
    (Map[Point, Set[Point]], Set[(Point, Point)]) = {
      if (segments.nonEmpty) {
        val s = segments.head
        val (p, newPolygons) = if (s.start.x > extremes(0).x && s.start.x < extremes(1).x && s.start.y > extremes(2).y && s.start.y < extremes(3).y) {
          val (m, b) = s.mAndB
          val crossing = if (m.isNaN) {
            if (s.left.x < s.right.x) Point(s.start.x, extremes(3).y) else Point(s.start.x, extremes(2).y)
          } else if (m == 0) {
            Point(extremes(siteExtremes.take(2).sortBy(p => Math.abs(p._1.x - s.start.x)).head._2).x, s.start.y) // ???
          } else {
            val (horizontal, vertical) = if (m > 0)
              (if (s.left.y > s.right.y) extremes(3).y else extremes(2).y, if (s.left.x > s.right.x) extremes(0).x else extremes(1).x)
            else (if (s.left.y > s.right.y) extremes(2).y else extremes(3).y, if (s.left.x > s.right.x) extremes(1).x else extremes(0).x)
            val hc = Point((horizontal - b) / m, horizontal)
            val vc = Point(vertical, m * vertical + b)
            if (s.start.distanceTo(hc) < s.start.distanceTo(vc)) hc else vc
          }
          (crossing, polygons + (s.left -> (polygons(s.left) + crossing)) + (s.right -> (polygons(s.right) + crossing)))
        } else (s.start, polygons)
        getRestOfEdges(segments.tail, newPolygons, crossings ++ Set((s.left, p), (s.right, p)))
      } else (polygons, crossings)
    }

    val (p, c) = getRestOfEdges(beach.segments, polygons)
    val newPolygons = (p /: c.groupBy(_._1).map { case (k, v) => (k, v.map(_._2)) }.filter { (p: (Point, Set[Point])) =>
      p._2.map(_.x).size == 2 && p._2.map(_.x).size > 1 && p._2.map(_.y).size > 1
    }.mapValues { s => (s.map(_.x), s.map(_.y)) }.mapValues { coords =>
      // wrong indexes are found for the test case 5
      val indexes = cornerIndexes.find(i => coords._1.contains(extremes(i._1).x) && coords._2.contains(extremes(i._2).y)).get
      Point(extremes(indexes._1).x, extremes(indexes._2).y)
    }) { case (map, (k, v)) => map + (k -> (map.getOrElse(k, Set()) + v)) }

    newPolygons.toList.map { (cell: (Point, Set[Point])) =>
      val vertexes = if (extremes.take(2).map(_.x).contains(cell._1.x) && extremes.drop(2).map(_.y).contains(cell._1.y)) cell._2 + cell._1 else cell._2
      Polygon(vertexes, cell._1)
    }
  }
}

object Fortunes {

  val EPSILON = 1e-10
}

sealed abstract class Event(val point: Point) extends Ordered[Event] {

  override def compare(that: Event): Int = point.compare(that.point)
}

case class SiteEvent(override val point: Point) extends Event(point)

case class CircleEvent(override val point: Point, vertex: Point) extends Event(point)

case class BeachLine(root: Point, segments: Vector[Segment] = Vector.empty, private val _circleEvents: Vector[CircleEvent] = Vector.empty) {

  private val log = Logger(LoggerFactory.getLogger(this.getClass))

  val circleEvents = TreeSet[Event](_circleEvents.filter(_ != null): _*)

  def manageEvent(event: Event, edges: Set[Edge]): (BeachLine, Set[Edge]) = event match {
    case se: SiteEvent =>
      val (newBeach, index) = addArc(se.point)
      val Last = newBeach.segments.size
      val indexes = index match {
        case -1     => List.empty[Int]
        case 0      => List(index + 2, index + 3)
        case Last   => List(index - 1, index)
        case i: Int => List(index - 1, index, index + 2, index + 3)
      }
      (newBeach.setCircleEvents(se.point.y, indexes), edges)
    case ce: CircleEvent =>
      val index = _circleEvents.indexOf(ce)
      val (leftEdge, rightEdge) = (leftSegment(index), rightSegment(index))
      (removeArc(index).setCircleEvents(ce.point.y, List(index - 1, index)), edges ++ Set(Edge(leftEdge.get, ce.vertex), Edge(rightEdge.get, ce.vertex)))
  }

  private def removeArc(index: Int): BeachLine = {
    require(index > 0 && index < _circleEvents.length)
    val newSegments =
      (segments.take(index - 1) :+ Segment(segments(index - 1).left, segments(index).right, _circleEvents(index).vertex)) ++ segments.drop(index + 1)
    val newCircleEvents = _circleEvents.take(index - 1) ++ Vector.fill(2)(null) ++ _circleEvents.drop(index + 2)
    BeachLine(root, newSegments, newCircleEvents)
  }

  private def addArc(newArcSite: Point): (BeachLine, Int) = {
    val (index, site) = arcOnSite(newArcSite)
    val Last = _circleEvents.size - 1
    val (newSegments, newCircleEvents) = if (site.y == newArcSite.y) {
      val crossPoint = Point((newArcSite.x + site.x) / 2, newArcSite.y)
      val newS = (segments.take(index) :+ Segment(site, newArcSite, crossPoint)) ++ segments.drop(index)
      val newCE = index match {
        case -1     => Vector.fill(2)(null)
        case 0      => Vector.fill(3)(null) ++ _circleEvents.drop(2)
        case Last   => _circleEvents.take(Last - 1) ++ Vector.fill(3)(null)
        case i: Int => _circleEvents.take(i - 1) ++ Vector.fill(4)(null) ++ _circleEvents.drop(i + 2)
      }
      (newS, newCE)
    } else {
      val crossPoint = Point(newArcSite.x, newArcSite.y - newArcSite.distanceToParabola(site))
      val newLHalfEdge = Segment(site, newArcSite, crossPoint)
      val newRHalfEdge = Segment(newArcSite, site, crossPoint)
      val newS = segments.take(index) ++ Vector(newLHalfEdge, newRHalfEdge) ++ segments.drop(index)
      val newCE = index match {
        case -1     => Vector.fill(3)(null)
        case 0      => Vector.fill(4)(null) ++ _circleEvents.drop(2)
        case Last   => _circleEvents.take(Last - 1) ++ Vector.fill(4)(null)
        case i: Int => _circleEvents.take(i - 1) ++ Vector.fill(5)(null) ++ _circleEvents.drop(i + 2)
      }
      (newS, newCE)
    }
    (BeachLine(root, newSegments, newCircleEvents), index)
  }

  private def arcOnSite(newSite: Point): (Int, Point) = {

    @tailrec
    def findArcNodeOnSite(s: Vector[(Segment, Int)]): (Int, Point) = {
      val arcCrossX = Parabola.arcCrossX(s.head._1.left, s.head._1.right, newSite.y)
      val sol = if (s.head._1.left.y < s.head._1.right.y) arcCrossX._1 else arcCrossX._2
      if (newSite.x < sol) (s.head._2, s.head._1.left)
      else if (s.tail.isEmpty) (s.head._2 + 1, s.head._1.right)
      else findArcNodeOnSite(s.tail)
    }

    if (segments.isEmpty) (-1, root)
    else findArcNodeOnSite(segments.zipWithIndex)
  }

  private def site(index: Int): Point = {
    val Last = segments.size
    index match {
      case Last   => segments.last.right
      case i: Int => segments(i).left
    }
  }

  private def leftSite(index: Int): Option[Point] = index match {
    case 0      => None
    case i: Int => Some(segments(i - 1).left)
  }

  private def leftSegment(index: Int): Option[Segment] = index match {
    case 0      => None
    case i: Int => Some(segments(i - 1))
  }

  private def rightSite(index: Int): Option[Point] = {
    val Last = segments.size
    index match {
      case Last   => None
      case i: Int => Some(segments(i).right)
    }
  }

  private def rightSegment(index: Int): Option[Segment] = {
    val Last = segments.size
    index match {
      case Last   => None
      case i: Int => Some(segments(i))
    }
  }

  private def setCircleEvents(sweepY: Double, indexes: List[Int]): BeachLine = {
    val newCircleEvents = indexes.foldLeft(_circleEvents) { (vector: Vector[CircleEvent], i: Int) =>
      if (i > segments.size) vector
      else vector.setCircleEvent(i, sweepY)
    }
    if (newCircleEvents.equals(_circleEvents)) BeachLine.this else BeachLine(root, segments, newCircleEvents)
  }

  implicit def vectorToCircleEvents(v: Vector[CircleEvent]): CircleEvents = CircleEvents(v)

  private[BeachLine] case class CircleEvents(v: Vector[CircleEvent]) {

    def setCircleEvent(index: Int, sweepY: Double): Vector[CircleEvent] = {
      val item = site(index)
      val (lSite, rSite) = (leftSite(index), rightSite(index))
      val (lSegment, rSegment) = (leftSegment(index), rightSegment(index))
      if (lSite.isEmpty || rSite.isEmpty) {
        log.debug(f"$sweepY No event: first or last arc")
        v
      } else if (lSite.get == rSite.get) {
        log.debug(f"$sweepY No event: lefter arc site equals righter arc site")
        v
      } else {
        val center = Circle.center(lSite.get, item, rSite.get)
        if (center.y.isNaN) {
          log.debug(f"$sweepY No event: the three arcs sites are on the same line")
          v
        } else {
          val eventPoint = Point(center.x, center.y + item.distanceTo(center))
          if (eventPoint.y < sweepY - Fortunes.EPSILON) {
            log.debug(f"$sweepY No event: circle event coordinate below sweep line")
            v
          } else if (lSegment.get.intersection(rSegment.get).isEmpty) {
            log.debug(f"$sweepY No event: edges do not cross")
            v
          } else {
            log.debug(f"$sweepY Event is added")
            v.updated(index, CircleEvent(eventPoint, center))
          }
        }
      }
    }
  }
}

abstract sealed class AbstractSegment(left: Point, right: Point, val start: Point) {

  lazy val midpoint = Point((left.x + right.x) / 2, (left.y + right.y) / 2)

  override def equals(obj: Any): Boolean = obj match {
    case s: Segment => start.equals(s.start)
    case _ => false
  }

  def intersection(s1: AbstractSegment, s2: AbstractSegment = this): Option[Point] = {
    val (s1m, s2m) = (s1.m, s2.m)
    val (s1hp, s2hp) = (s1.halfPlane, s2.halfPlane)
    val s1Vec = if (s1hp * s1m > 0 || s1m == 0 && s1hp > 0) Point(1, s1m) else Point(-1, -s1m)
    val s2Vec = if (s2hp * s2m > 0 || s2m == 0 && s2hp > 0) Point(1, s2m) else Point(-1, -s2m)
    val dx = s2.start.x - s1.start.x
    val dy = s2.start.y - s1.start.y
    if (s2m.isNaN)
      if (s2hp * (s1m * dx - dy) >= -Fortunes.EPSILON && s1Vec.x * dx >= -Fortunes.EPSILON)
        Some(Point(s2.start.x, s1.start.y + s1m * dx))
      else None
    else if (s1m.isNaN)
      if (s1hp * (s2m * dx - dy) <= Fortunes.EPSILON && s2Vec.x * dx <= Fortunes.EPSILON)
        Some(Point(s1.start.x, s2.start.y - s2m * dx))
      else None
    else {
      val det = s2Vec.x * s1Vec.y - s2Vec.y * s1Vec.x
      if (det == 0) None
      else {
        val u = (dy * s2Vec.x - dx * s2Vec.y) / det
        val v = (dy * s1Vec.x - dx * s1Vec.y) / det
        if (u >= -Fortunes.EPSILON && v >= Fortunes.EPSILON || u >= Fortunes.EPSILON && v >= -Fortunes.EPSILON)
          Some(Point(s1.start.x + u * s1Vec.x, s1.start.y + u * s1Vec.y))
        else None
      }
    }
  }

  def m: Double =
    if (left.y == right.y) Double.NaN else -(left.x - right.x) / (left.y - right.y)

  def halfPlane: Int = if (left.x < right.x) 2
  else if (left.x > right.x) -2
  else if (left.x == right.x && left.y > right.y) 1
  else -1

  def mAndB: (Double, Double) = {
    if (start.x == midpoint.x) (Double.NaN, start.x) else {
      val m = (start.y - midpoint.y) / (start.x - midpoint.x)
      (m, start.y - m * start.x)
    }
  }
}

case class Segment(left: Point, right: Point, override val start: Point) extends AbstractSegment(left, right, start)

case class Edge(left: Point, right: Point, override val start: Point, end: Point) extends AbstractSegment(left, right, start)

object Edge {

  def apply(segment: Segment, end: Point): Edge = new Edge(segment.left, segment.right, segment.start, end)
}

object Parabola {

  def arcCrossX(f1: Point, f2: Point, q: Double): (Double, Double) = {
    if (f1.y != f2.y) {
      val s1 = (f1.y * f2.x - f1.x * f2.y + f1.x * q - f2.x * q +
                Math.sqrt((f1.x * f1.x + f1.y * f1.y - 2 * f1.x * f2.x + f2.x * f2.x - 2 * f1.y * f2.y + f2.y * f2.y) *
                          (f1.y * f2.y - f1.y * q - f2.y * q + q * q))) / (f1.y - f2.y)
      val s2 = (f1.y * f2.x - f1.x * f2.y + f1.x * q - f2.x * q -
                Math.sqrt((f1.x * f1.x + f1.y * f1.y - 2 * f1.x * f2.x + f2.x * f2.x - 2 * f1.y * f2.y + f2.y * f2.y) *
                          (f1.y * f2.y - f1.y * q - f2.y * q + q * q))) / (f1.y - f2.y)
      if (s1 < s2) (s1, s2) else (s2, s1)
    } else ((f1.x + f2.x) / 2, (f1.x + f2.x) / 2)
  }
}

object Circle {

  def center(a: Point, b: Point, c: Point): Point = {
    val d = (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y)
    if (d == 0) Point(Double.NaN, Double.NaN)
    else {
      val xc = (((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.y - c.y) -
                ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.y - c.y)) / d
      val yc = (((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.x - c.x) -
                ((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.x - c.x)) / d
      Point(xc, yc)
    }
  }
}